extern crate cmudict_core;
extern crate reqwest;

use std::env;
use std::path::Path;
use std::io::{self, BufRead, Write};
use std::fs::{OpenOptions, File};
use std::collections::HashSet;

pub fn main() {
    let out_dir = env::var_os("OUT_DIR").unwrap();

    let dest = Path::new(&out_dir).join("lib.rs");
    let src = Path::new(&out_dir).join("cmudict.dict");
    let mut srcfile = OpenOptions::new().read(true).write(true).create(true).open(&src).expect("Could not open dict file for writing");
    let mut r = reqwest::get("https://raw.githubusercontent.com/cmusphinx/cmudict/master/cmudict.dict").expect("Could not download dict file");
    r.copy_to(&mut srcfile).expect("Could not copy to destination");

    let succeed = expand_rules(&src, &dest);
    println!("{:#?}", succeed);
    assert!(succeed.is_ok());

}

fn expand_rules(src: &Path, dst: &Path) -> io::Result<()> {
    let rules = File::open(src)?;
    let reader = io::BufReader::new(rules);
    let mut out = File::create(dst)?;
    let lines = reader.lines();

    writeln!(out, r#"
lazy_static! {{
    static ref INDEX: BTreeMap<&'static str, u32> = btreemap!{{"#)?;

    let mut lines_iter = lines.enumerate().peekable();
    let mut prefixes = HashSet::new();

    loop {
        if lines_iter.peek().is_none() {
            break
        }

        let (idx, line) = lines_iter.next().unwrap();
        let line = match line {
            Ok(l) => l,
            Err(e) => {
                eprintln!("Error reading line, {}", e);
                continue;
            }
        };
        if line.starts_with(";;") {
            continue;
        }

        let mut it = line.splitn(2, ' ');
        let label = it.next().expect("parse error");

        let label = split_label(label);
        let start = if label.len() < 2 {
            &label[..]
        } else {
            &label[..2]
        };

        if prefixes.contains(start) {
            continue;
        }

        writeln!(out, "      {:?} => {},", start, idx + 1)?;
        prefixes.insert(start.to_string());
    }

    writeln!(out, r#"
    }};
}}"#)?;

    Ok(())
}

